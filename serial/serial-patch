--- linux-2.4.37.7/drivers/char/serial.c.orig	2009-11-07 08:52:20.000000000 -0800
+++ linux-2.4.37.7/drivers/char/serial.c	2011-11-09 01:09:21.437930441 -0800
@@ -163,7 +163,7 @@
 #undef CONFIG_SERIAL_CONSOLE
 #endif
 
-#define CONFIG_SERIAL_RSA
+//#define CONFIG_SERIAL_RSA
 
 #define RS_STROBE_TIME (10*HZ)
 #define RS_ISR_PASS_LIMIT 256
@@ -285,7 +285,9 @@
 #endif
 
 static unsigned detect_uart_irq (struct serial_state * state);
+#ifdef CONFIG_SERIAL_RSA
 static void autoconfig(struct serial_state * state);
+#endif
 static void change_speed(struct async_struct *info, struct termios *old);
 static void rs_wait_until_sent(struct tty_struct *tty, int timeout);
 
@@ -2378,6 +2380,7 @@
 	return 0;
 }
 
+#ifdef CONFIG_SERIAL_RSA
 static int do_autoconfig(struct async_struct * info)
 {
 	int irq, retval;
@@ -2404,6 +2407,7 @@
 		return retval;
 	return 0;
 }
+#endif
 
 /*
  * rs_break() --- routine which turns the break handling on or off
@@ -2631,8 +2635,10 @@
 		case TIOCSSERIAL:
 			return set_serial_info(info,
 					       (struct serial_struct *) arg);
+#ifdef CONFIG_SERIAL_RSA
 		case TIOCSERCONFIG:
 			return do_autoconfig(info);
+#endif
 
 		case TIOCSERGETLSR: /* Get line status register */
 			return get_lsr_info(info, (unsigned int *) arg);
@@ -3507,6 +3513,7 @@
 	return (irq > 0)? irq : 0;
 }
 
+#if 0
 /*
  * This is a quickie test to see how big the FIFO is.
  * It doesn't work at all the time, more's the pity.
@@ -3662,7 +3669,6 @@
 	
 	if (!CONFIGURED_SERIAL_PORT(state))
 		return;
-		
 	info = &scr_info;	/* This is just for serial_{in,out} */
 
 	info->magic = SERIAL_MAGIC;
@@ -3864,6 +3870,7 @@
 	
 	restore_flags(flags);
 }
+#endif
 
 int register_serial(struct serial_struct *req);
 void unregister_serial(int line);
@@ -5421,6 +5428,26 @@
 	int i;
 	struct serial_state * state;
 
+	// WRT54G - Hardcoded Initialization
+	struct serial_struct s;
+	int result;
+	
+	s.line = 0;
+	s.iomem_base = (void *) 0xb8000300;
+	s.irq = 3;
+	s.baud_base = 20000000 / 16;
+	s.flags = 0;
+	s.io_type = SERIAL_IO_MEM;
+	s.iomem_reg_shift = 0;
+	s.type = PORT_16550A;
+	result = early_serial_setup(&s);
+
+	s.line = 1;
+	s.iomem_base = (void *) 0xb8000400;
+	s.irq = 3;
+	result = early_serial_setup(&s);
+	////////
+
 	init_bh(SERIAL_BH, do_serial_bh);
 	init_timer(&serial_timer);
 	serial_timer.function = rs_timer;
@@ -5458,7 +5485,7 @@
 #if (LINUX_VERSION_CODE > 0x2032D && defined(CONFIG_DEVFS_FS))
 	serial_driver.name = "tts/%d";
 #else
-	serial_driver.name = "ttyS";
+	serial_driver.name = "ttyS%d";
 #endif
 	serial_driver.major = TTY_MAJOR;
 	serial_driver.minor_start = 64 + SERIAL_DEV_OFFSET;
@@ -5507,7 +5534,7 @@
 #if (LINUX_VERSION_CODE > 0x2032D && defined(CONFIG_DEVFS_FS))
 	callout_driver.name = "cua/%d";
 #else
-	callout_driver.name = "cua";
+	callout_driver.name = "cua%d";
 #endif
 	callout_driver.major = TTYAUX_MAJOR;
 	callout_driver.subtype = SERIAL_TYPE_CALLOUT;
@@ -5521,6 +5548,7 @@
 	if (tty_register_driver(&callout_driver))
 		panic("Couldn't register callout driver\n");
 	
+#if 0
 	for (i = 0, state = rs_table; i < NR_PORTS; i++,state++) {
 		state->magic = SSTATE_MAGIC;
 		state->line = i;
@@ -5547,6 +5575,8 @@
 		if (state->flags & ASYNC_BOOT_AUTOCONF)
 			autoconfig(state);
 	}
+#endif
+
 	for (i = 0, state = rs_table; i < NR_PORTS; i++,state++) {
 		if (state->type == PORT_UNKNOWN)
 			continue;
@@ -5598,6 +5628,7 @@
 	if (HIGH_BITS_OFFSET)
 		rs_table[i].port += (unsigned long) req->port_high << 
 							HIGH_BITS_OFFSET;
+	rs_table[i].line = i;
 	rs_table[i].irq = req->irq;
 	rs_table[i].flags = req->flags;
 	rs_table[i].close_delay = req->close_delay;
@@ -5689,7 +5720,9 @@
 		info->iomem_base = req->iomem_base;
 		info->iomem_reg_shift = req->iomem_reg_shift;
 	}
+#ifdef CONFIG_SERIAL_RSA
 	autoconfig(state);
+#endif
 	if (state->type == PORT_UNKNOWN) {
 		restore_flags(flags);
 		printk("register_serial(): autoconfig failed\n");
--- linux-2.4.37.7/Makefile.orig	2009-11-07 08:52:20.000000000 -0800
+++ linux-2.4.37.7/Makefile	2011-11-09 01:20:24.908579459 -0800
@@ -5,7 +5,8 @@
 
 KERNELRELEASE=$(VERSION).$(PATCHLEVEL).$(SUBLEVEL)$(EXTRAVERSION)
 
-ARCH := $(shell uname -m | sed -e s/i.86/i386/ -e s/sun4u/sparc64/ -e s/arm.*/arm/ -e s/sa110/arm/)
+#ARCH := $(shell uname -m | sed -e s/i.86/i386/ -e s/sun4u/sparc64/ -e s/arm.*/arm/ -e s/sa110/arm/)
+ARCH := mips
 KERNELPATH=kernel-$(shell echo $(KERNELRELEASE) | sed -e "s/-//g")
 
 CONFIG_SHELL := $(shell if [ -x "$$BASH" ]; then echo $$BASH; \
@@ -19,14 +20,15 @@
 HOSTCC  	= gcc
 HOSTCFLAGS	= -Wall -Wstrict-prototypes -O2 -fomit-frame-pointer
 
-CROSS_COMPILE 	=
+#CROSS_COMPILE 	=
+CROSS_COMPILE   = /home/eta/ddwrt/toolchain-i386_mipsel_gcc4.1.2/bin/mipsel-linux-uclibc-
 
 #
 # Include the make variables (CC, etc...)
 #
 
 AS		= $(CROSS_COMPILE)as
-LD		= $(CROSS_COMPILE)ld
+LD		= $(CROSS_COMPILE)ld -EL
 CC		= $(CROSS_COMPILE)gcc
 CPP		= $(CC) -E
 AR		= $(CROSS_COMPILE)ar
